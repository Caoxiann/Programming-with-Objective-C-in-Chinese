#四、定制已有的类
每一个对象都有它明确的任务，例如封装数据、在界面上展示它的内容、控制信息流等。之前也讲过，类的声明部分定义了它的对象与外部交互的方法，通过这些方法来完成它的任务。

在某些特定的场合，你想让你的类拥有一些特定的方法来解决某些问题，这样这个类就需要被拓展。举个例子，当你的app需要经常在屏幕上显示一个字符串的时候，比起每次都重复创建一个用来显示字符串的对象，更方便的做法是让你的字符串对象本身就拥有显示在屏幕上的能力。  

在这种情况下，给原来的类的声明部分中加入新的方法的做法并不常用。能在屏幕上显示出来这个功能不是字符串`NSString`这个类的主要功能，而且因为`NSString`类是Objective-C的类库中的类，你也不能随意去更改它的声明部分和实现部分。如果你想用类的继承特性来为`NSString`类的字类添加显示的功能，还是会遇到问题。因为如果你这样做，`NSString`类的其他子类，例如`NSMutableString`类，就无法使用这个新功能了。而且，尽管`NSString`类可以同时在OS X（macOS）和iOS系统中使用，但是要使它显示在屏幕上的代码却是不同的，这就需要多个子类来适配不同的平台。

为了解决以上问题，Objective-C提供了 *类别（categories）* 和 *class extensions* 这两种方式来为已存在的类加入新的方法。

##为类添加方法的类别
如果你想为一个已存在的类添加一个实用的功能的话，使用类别（categories）会是一个很好的选择。

和普通的Objective-C类的声明一样，声明一个类别的语法要用到@interface这个关键字，但不需要声明这个类别的继承关系，取而代之的是，我们需要在圆括号里具体说明这个类别的名字。这里是一个简单的例子：
```
@interface ClassName (CategoryName)

@end
```

任何一个类都可以声明一个类别，就连你不知道它实现代码的类库中的类都可以。你在类别中声明的任何方法都可以在它的实例对象和子类的实例对象中使用。在运行过程中，类别中声明和实现的方法和原来的类中声明的方法没有任何区别。

以前面的章节中提到的`XYZPerson`类作为例子，这个类有两个属性，分别是firstName和lastName。如果你打算做一个纪录成绩的app的话，你经常需要把last name放在first name前面：
```
Appleseed, John

Doe, Jane

Smith, Bob

Warwick, Kate
```

除了每次使用时产生一个`last name,first name`格式的字符串，你还可以为`XYZPerson`类添加一个类别，就像这样：
```
#import "XYZPerson.h"

 

@interface XYZPerson (XYZPersonNameDisplayAdditions)

- (NSString *)lastNameFirstNameString;

@end
```
在这个例子中，`XYZPersonNameDisplayAdditions`这个类别声明了一个新的方法，这个方法返回一个`last name,first name`格式的字符串。

一个类别通常和它的原类在不同的头文件中定义，并在不同的实现文件中实现。在上面的例子中，这个类别被定义在一个叫`XYZPerson+XYZPersonNameDisplayAdditions.h`头的文件中。尽管类别中新定义的方法能被它及其所有子类的对象使用，但是在使用前你必须你必须在该文件中引入这个类别的头文件，否则你将遇到一个编译错误。

一个类别的实现长这样：
```
#import "XYZPerson+XYZPersonNameDisplayAdditions.h"

 

@implementation XYZPerson (XYZPersonNameDisplayAdditions)

- (NSString *)lastNameFirstNameString {

    return [NSString stringWithFormat:@"%@, %@", self.lastName, self.firstName];

}

@end
```
一旦你声明并且实现了新添的方法，你就可以在任何这个类的对象中使用这个方法，就好像这个方法是在类中原本就有的一样。
```
#import "XYZPerson+XYZPersonNameDisplayAdditions.h"

@implementation SomeObject

- (void)someMethod {

    XYZPerson *person = [[XYZPerson alloc] initWithFirstName:@"John"

                                                    lastName:@"Doe"];

    XYZShoutingPerson *shoutingPerson =

                        [[XYZShoutingPerson alloc] initWithFirstName:@"Monica"

                                                            lastName:@"Robinson"];

 

    NSLog(@"The two people are %@ and %@",

         [person lastNameFirstNameString], [shoutingPerson lastNameFirstNameString]);

}

@end
```
除了可以为已有类添加新的方法外，你还可以用类别来分解那些实现起来很复杂的类。比方说，你可以把关于在界面上显示的代码，例如几何计算、颜色和倾斜度等等放在另一个文件中，和其他该类的实现代码分开存放。这样做还有一个好处，就是可以为一个类在适配不同的平台（OS X或者iOS）时提供不同的实现方法，而无需新建一个类。

实例方法和类方法都可以在类别中声明，但是一般不在类别中声明一个新的属性，尽管这样做在语法上没有错误，但是在类别中声明一个新的实例变量是不可能的。这意味着编译器既不会 *实现（synthesize)* 任何一个在类别中声明的实例变量，也不会*实现（synthesize)* 任何一个关于这些实例变量的方法。你可以在这个类别的实现文件中实现这种方法，但是除非这个实例变量的值被原来的类中的实例变量存起来，否则你是无法追踪这个声明在类别中的实例变量的。

为一个已有类添加新的属性的唯一方法就是使用*类的延伸(class extension)*,这将在接下来的章节介绍。

>注意： Cocoa 和 Cocoa Touch类库中包括了很多原始类的类别。`NSString`类在OS X系统的屏幕上显示字符串的功能在`NSStringDrawing`这个类别中实现了。这个类别包含了`drawAtPoint:withAttributes:`和`drawInRect:withAttributes:`等方法。在iOS系统中，实现这个功能的类别是`UIStringDrawing`，其中包含了`drawAtPoint:withFont:`和`drawInRect:withFont:`等方法。

###避免类别中方法名的冲突
因为类别中的方法名是添加在原来的类中的，所以你需要很谨慎的为这些方法命名，避免它们与原来的类的方法发生冲突。

如果一个定义在类别中的方法名和原来的类中的一个方法名重复了，或者和该类的另一个类别的一个方法名重复了，在运行过程中具体调用哪个方法来实现会是随机决定的。这种情况很少在为自己的类添加类别时发生，而经常在为Cocoa 和 Cocoa Touch类库的类添加方法时发生。

举个例子，假如一个app需要从一个远程网络服务器中获取数据，这就需要一个方法来为字符串编码成Base64形式。这时候就需要为`NSString`类添加一个类别，并且在其中添加一个返回编码后的字符串的`base64EncodedString`方法。但当你把其他类库加进来时，问题就发生了。其他类库也许也会为`NSString`这个类添加一个叫`base64EncodedString`的方法。那么在运行的时候，只有一个方法会被使用，而这个方法到底是哪一个，是不确定的。

还有另一个问题，就是当一个类添加了一个方法之后，有可能在接下来的代码迭代版本中，又添加了另一个同名的方法，这样新旧两个方法就冲突了。举个例子，`NSSortDescriptor`这个类中有一个叫`initWithKey:ascending:`的初始化方法，这个方法在早期的OS X和iOS版本中是没有相关的类方法。按照命名传统，这个类方法应该叫做`sortDescriptorWithKey:ascending:`，所以你可以在`NSSortDescriptor`这个类上添加这个类方法。在早期的OS X和iOS版本中这样做是没有问题的，但是在Mac OS X 10.6和iOS4.0版本之后，官方类库中就为`NSSortDescriptor`这个添加了`sortDescriptorWithKey:ascending:`这个类方法，这就意味着在新版本的系统中你自己命名的方法和类库中的方法冲突了，必须要手动解决这个问题。

为了避免这些不必要的冲突，很有必要为新添加的方法名添加一个前缀，特别是那些在官方类库中的类。这种做法有点像为你自己的类名添加一个前缀。你可以使用你名字的首字母来作为你的前缀，包括方法名和类名的前缀。除此之外，还可以用下划线把前缀和方法名连接起来。在`NSSortDescriptor`这个例子中，你自定义的类别可以长这样：
```
@interface NSSortDescriptor (XYZAdditions)

+ (id)xyz_sortDescriptorWithKey:(NSString *)key ascending:(BOOL)ascending;

@end
```
这样做可以确保在运行的时候会调用正确的方法而没有产生歧义。你的方法是这样被调用的:
```
 NSSortDescriptor *descriptor =

               [NSSortDescriptor xyz_sortDescriptorWithKey:@"name" ascending:YES];

```



